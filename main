"""
Telegram Quiz Bot â€” 15s timed MCQ with speed-based scoring + leaderboard
Dependencies: python-telegram-bot==21.*
"""

from __future__ import annotations
import asyncio, json, os, sqlite3, time
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CallbackQueryHandler, CommandHandler, ContextTypes

DB_PATH = Path("quiz.db")
QUESTIONS_PATH = Path("questions.json")
QUESTION_TIME_LIMIT = 15   # seconds
POINTS_MAX = 1000          # fastest perfect
POINTS_MIN = 100           # correct at 15s gets min points

@dataclass
class Question:
    id: int
    text: str
    options: List[str]
    correct: int  # index 0..3

SAMPLE_QUESTIONS = [
    {"text": "What is the capital of France?", "options": ["Paris","Berlin","Madrid","Rome"], "correct": 0},
    {"text": "Which planet is the Red Planet?", "options": ["Venus","Mars","Jupiter","Mercury"], "correct": 1},
    {"text": "2 + 2 Ã— 3 = ?", "options": ["10","12","8","6"], "correct": 0},
]

def load_questions() -> List[Question]:
    if QUESTIONS_PATH.exists():
        data = json.loads(QUESTIONS_PATH.read_text(encoding="utf-8"))
    else:
        data = SAMPLE_QUESTIONS
    out: List[Question] = []
    for i, q in enumerate(data, start=1):
        if len(q.get("options", [])) != 4:
            raise ValueError(f"Question {i} must have exactly 4 options")
        correct = int(q.get("correct", -1))
        if not 0 <= correct < 4:
            raise ValueError(f"Question {i} has invalid correct index {correct}")
        out.append(Question(id=i, text=q["text"], options=q["options"], correct=correct))
    return out

class QuizDB:
    def __init__(self, path: Path):
        self.conn = sqlite3.connect(path)
        self.conn.execute("PRAGMA journal_mode=WAL;")
        self._init()

    def _init(self):
        c = self.conn.cursor()
        c.execute("""
            CREATE TABLE IF NOT EXISTS chats (
              chat_id INTEGER PRIMARY KEY,
              current_q INTEGER DEFAULT 0,
              started_at INTEGER,
              is_active INTEGER DEFAULT 0,
              question_started_at INTEGER
            );
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS users (
              chat_id INTEGER,
              user_id INTEGER,
              name TEXT,
              PRIMARY KEY (chat_id, user_id)
            );
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS answers (
              chat_id INTEGER,
              q_index INTEGER,
              user_id INTEGER,
              is_correct INTEGER,
              elapsed_ms INTEGER,
              points INTEGER,
              PRIMARY KEY (chat_id, q_index, user_id)
            );
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS questions (
              chat_id INTEGER,
              q_index INTEGER,
              text TEXT,
              opt0 TEXT, opt1 TEXT, opt2 TEXT, opt3 TEXT,
              correct INTEGER,
              PRIMARY KEY (chat_id, q_index)
            );
        """)
        self.conn.commit()

    # session
    def start_quiz(self, chat_id: int, questions: List[Question]):
        cur = self.conn.cursor()
        cur.execute(
            "INSERT OR REPLACE INTO chats(chat_id, current_q, started_at, is_active, question_started_at) VALUES(?,?,?,?,?)",
            (chat_id, 0, int(time.time()), 1, None),
        )
        cur.execute("DELETE FROM questions WHERE chat_id=?", (chat_id,))
        for idx, q in enumerate(questions, start=1):
            cur.execute(
                "INSERT INTO questions(chat_id,q_index,text,opt0,opt1,opt2,opt3,correct) VALUES(?,?,?,?,?,?,?,?)",
                (chat_id, idx, q.text, q.options[0], q.options[1], q.options[2], q.options[3], q.correct),
            )
        self.conn.commit()

    def end_quiz(self, chat_id: int):
        self.conn.execute("UPDATE chats SET is_active=0 WHERE chat_id=?", (chat_id,))
        self.conn.commit()

    def get_chat_state(self, chat_id: int) -> Optional[Tuple[int, int, int]]:
        row = self.conn.execute(
            "SELECT current_q, is_active, question_started_at FROM chats WHERE chat_id=?", (chat_id,)
        ).fetchone()
        return row if row else None

    def set_question_start(self, chat_id: int, q_index: int, started_at: int):
        self.conn.execute(
            "UPDATE chats SET current_q=?, question_started_at=? WHERE chat_id=?",
            (q_index, started_at, chat_id),
        )
        self.conn.commit()

    def get_question(self, chat_id: int, q_index: int) -> Optional[Question]:
        row = self.conn.execute(
            "SELECT text,opt0,opt1,opt2,opt3,correct FROM questions WHERE chat_id=? AND q_index=?",
            (chat_id, q_index),
        ).fetchone()
        if not row: return None
        text, *opts, correct = row
        return Question(id=q_index, text=text, options=opts, correct=correct)

    # users & answers
    def upsert_user(self, chat_id: int, user_id: int, name: str):
        self.conn.execute(
            "INSERT OR REPLACE INTO users(chat_id, user_id, name) VALUES(?,?,?)",
            (chat_id, user_id, name[:64]),
        )
        self.conn.commit()

    def record_answer(self, chat_id: int, q_index: int, user_id: int, is_correct: bool, elapsed_ms: int, points: int) -> bool:
        try:
            self.conn.execute(
                "INSERT INTO answers(chat_id,q_index,user_id,is_correct,elapsed_ms,points) VALUES(?,?,?,?,?,?)",
                (chat_id, q_index, user_id, 1 if is_correct else 0, elapsed_ms, points),
            )
            self.conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False

    def leaderboard(self, chat_id: int, limit: int = 20):
        rows = self.conn.execute(
            """
            SELECT u.name, COALESCE(SUM(a.points),0) AS pts
            FROM users u
            LEFT JOIN answers a ON u.chat_id=a.chat_id AND u.user_id=a.user_id
            WHERE u.chat_id=?
            GROUP BY u.name
            ORDER BY pts DESC
            LIMIT ?
            """,
            (chat_id, limit),
        ).fetchall()
        return [(r[0], int(r[1] or 0)) for r in rows]

db = QuizDB(DB_PATH)
QUESTIONS = load_questions()

def compute_points(elapsed_sec: float, correct: bool) -> int:
    if not correct: return 0
    if elapsed_sec >= QUESTION_TIME_LIMIT: return 0
    remaining = max(0.0, QUESTION_TIME_LIMIT - elapsed_sec)
    frac = remaining / QUESTION_TIME_LIMIT
    return int(max(0, POINTS_MIN + (POINTS_MAX - POINTS_MIN) * frac))

def keyboard(q: Question) -> InlineKeyboardMarkup:
    btns = [[InlineKeyboardButton(text=f"{chr(65+i)}. {opt}", callback_data=f"ans:{i}")]
            for i, opt in enumerate(q.options)]
    return InlineKeyboardMarkup(btns)

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "ðŸ‘‹ Welcome!\n/startquiz to begin a 15s-per-question quiz.\n"
        "Faster correct answers = more points.\n/leaderboard to see scores."
    )

async def cmd_startquiz(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    db.start_quiz(chat.id, QUESTIONS)
    await update.message.reply_text(
        f"ðŸŽ‰ Quiz starting! {len(QUESTIONS)} questions. {QUESTION_TIME_LIMIT}s each. Good luck!"
    )
    await send_question(context, chat.id, 1)

async def send_question(context: ContextTypes.DEFAULT_TYPE, chat_id: int, q_index: int):
    q = db.get_question(chat_id, q_index)
    if not q:
        await announce_results(context, chat_id); return
    db.set_question_start(chat_id, q_index, int(time.time()))
    await context.bot.send_message(chat_id=chat_id, text=f"Q{q_index}. {q.text}\n(â± {QUESTION_TIME_LIMIT}s)",
                                   reply_markup=keyboard(q))
    context.job_queue.run_once(reveal_and_next, when=QUESTION_TIME_LIMIT, data={"chat_id": chat_id, "q_index": q_index})

async def reveal_and_next(context: ContextTypes.DEFAULT_TYPE):
    chat_id = context.job.data["chat_id"]
    q_index = context.job.data["q_index"]
    q = db.get_question(chat_id, q_index)
    if not q: return
    correct_letter = chr(65 + q.correct)
    await context.bot.send_message(chat_id=chat_id, text=f"â° Time!\n\nQ{q_index} answer: {correct_letter}. {q.options[q.correct]}")
    next_idx = q_index + 1
    if db.get_question(chat_id, next_idx):
        await send_question(context, chat_id, next_idx)
    else:
        await announce_results(context, chat_id)

async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    chat_id = query.message.chat.id
    state = db.get_chat_state(chat_id)
    if not state: 
        await query.answer("No active quiz.", show_alert=True); return
    current_q, is_active, started_at = state
    if not is_active: 
        await query.answer("Quiz not active.", show_alert=True); return
    q = db.get_question(chat_id, current_q)
    if not q: 
        await query.answer(); return

    user = query.from_user
    db.upsert_user(chat_id, user.id, (user.full_name or user.username or str(user.id)))

    try:
        choice = int(query.data.split(":")[1])
    except Exception:
        await query.answer(); return

    now = time.time()
    elapsed = QUESTION_TIME_LIMIT if started_at is None else max(0.0, now - started_at)
    is_correct = (choice == q.correct)
    points = compute_points(elapsed, is_correct)
    ok = db.record_answer(chat_id, current_q, user.id, is_correct, int(elapsed * 1000), points)
    if not ok:
        await query.answer("Your first answer already counted.", cache_time=2); return
    await query.answer(f"âœ… +{points} pts" if is_correct else "âŒ", cache_time=2)

async def cmd_leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    lines = ["ðŸ† Leaderboard"]
    for i, (name, pts) in enumerate(db.leaderboard(chat.id, 20), start=1):
        medal = "ðŸ¥‡" if i == 1 else "ðŸ¥ˆ" if i == 2 else "ðŸ¥‰" if i == 3 else f"{i}."
        lines.append(f"{medal} {name} â€” {pts} pts")
    await update.message.reply_text("\n".join(lines))

async def cmd_stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    db.end_quiz(update.effective_chat.id)
    await update.message.reply_text("ðŸ›‘ Quiz ended. Use /startquiz to start again.")

def build_app() -> Application:
    token = os.getenv("BOT_TOKEN")
    if not token:
        raise RuntimeError("Please set BOT_TOKEN env var.")
    app = Application.builder().token(token).build()
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("startquiz", cmd_startquiz))
    app.add_handler(CommandHandler("leaderboard", cmd_leaderboard))
    app.add_handler(CommandHandler("stopquiz", cmd_stop))
    app.add_handler(CallbackQueryHandler(handle_answer, pattern=r"^ans:\d$"))
    return app

if __name__ == "__main__":
    print("Starting botâ€¦")
    build_app().run_polling(close_loop=False)
